//////////////////////////////////////////////////////////////////////
/// @file state.hpp
/// @author Owen Chiaventone
/// @brief Chess state modelling, generation, and transitions
//////////////////////////////////////////////////////////////////////

#ifndef CPP_CLIENT_STATE_HPP
#define CPP_CLIENT_STATE_HPP

#include "../impl/chess.hpp"
#include "../game.hpp"
#include "../game_object.hpp"
#include "../move.hpp"
#include "../piece.hpp"
#include "../player.hpp"

#include "../../../joueur/src/base_ai.hpp"
#include "../../../joueur/src/attr_wrapper.hpp"

#include "action.hpp"
#include <iostream>

class State
{
public:
    // Create a state from the chess game
    State(const cpp_client::chess::Game &game);

    // The default copy constructor is fine, no need to override

    // Generate all valid actions for the
    // specified player from this board state
    // @param player_id : 0 for white
    //                    1 for black
    // It's the user's responsibility to make sure it's actually
    // the player's turn.
    std::vector<Action> available_actions(int player_id) const;

    // Returns a copy of the state with the given action applied
    State apply(const Action &action) const;

    // Tell if a player is in check
    // @param player_id : 0 for white
    //                    1 for black
    bool in_check(int player_id) const;

    bool friend operator==(const State &lhs, const State &rhs);

    long hash() const {return m_hash;}

    // Evaluates the strength of the specified player
    // @param player_id : 0 for white
    //                    1 for black
    // @return strength, Higher numbers are better.
    //                   Will never be lower than 0
    int heuristic_eval(int player_id) const;

    bool is_non_quiescent() const;

    int get_active_player() const;

private:
    // Calculates all actions allowed by traditional moves of chess
    // Including actions that could put the player in check
    std::vector<Action> all_actions(int player_id) const;

    // Apply an action in place
    // @param action must be a valid action generated by
    //        available_actions(). Attempting to apply
    //        an action not generated from this state
    //        results in undefined behavior.
    //        It probably won't segfault, but anything
    //        else is on you.
    // @post collision map, player's pieces,
    //       castling status, en_passant status updated
    void mutate(const Action &action);

    // Pretty self explanatory. No side effects.
    bool is_clear(const Space &space) const;
    bool has_opponent_piece(Space space, int player_id) const;

    // Calculates moves in straight lines from the given piece
    // Straight lines are defined as multiples of directions
    // May move into an empty space or an opponent's piece
    //
    // @post Moves added to actions
    void straight_line_moves(const PieceModel &piece, std::vector<Space> directions, int player_id,
                             std::vector<Action> &actions) const;

    void remove_piece(int player_id, const Space& location);

    void recalc_hash();

    int m_active_player;

    // Arrays of 2 - one for each player
    std::vector<PieceModel> m_player_pieces[2];      // The main data structure where pieces are stored.
    castling_status_type m_castling_status[2];       // If players can castle
    Space m_en_passant;                              // Target space for en passant, if any

    // Just for quick checks. All real operations are on the player pieces vector
    // Contains piece codes with the same notation as used in the print_board example
    // White pieces are uppercase, black pieces are lowercase
    // A null character (0x00) is used for an empty space
    char m_collision_map[8][8];

    long m_hash;
};

#endif //CPP_CLIENT_STATE_HPP
